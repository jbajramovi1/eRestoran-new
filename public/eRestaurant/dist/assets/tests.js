'use strict';

define('e-restaurant-fe/tests/app.lint-test', [], function () {
  'use strict';

  QUnit.module('ESLint | app');

  QUnit.test('app.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'app.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/add-location.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/add-location.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/add-restaurant.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/add-restaurant.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/add-user.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/add-user.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/admin-locations.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/admin-locations.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/admin-restaurants.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/admin-restaurants.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/admin-users.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/admin-users.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/dashboard-component.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/dashboard-component.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/rate-modal.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/rate-modal.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/reservation-bar.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/reservation-bar.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/restaurant-basic.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/restaurant-basic.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/restaurant-menu.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/restaurant-menu.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/restaurant-tables.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/restaurant-tables.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('components/table-search.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'components/table-search.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('controllers/add-location.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'controllers/add-location.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('controllers/adminpanel.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'controllers/adminpanel.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('controllers/application.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'controllers/application.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('controllers/login.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'controllers/login.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('controllers/register.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'controllers/register.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('controllers/reservation-bar.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'controllers/reservation-bar.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('controllers/restaurant.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'controllers/restaurant.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('models/account.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'models/account.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('models/base-model.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'models/base-model.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('models/comment.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'models/comment.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('models/menu.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'models/menu.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('models/menuitem.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'models/menuitem.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('models/restaurant.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'models/restaurant.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('resolver.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'resolver.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('router.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'router.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('routes/adminpanel.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'routes/adminpanel.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('routes/home.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'routes/home.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('routes/login.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'routes/login.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('routes/register.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'routes/register.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('routes/restaurant.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'routes/restaurant.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('services/account-service.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'services/account-service.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('services/admin-service.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'services/admin-service.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('services/comment-service.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'services/comment-service.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('services/reservation-service.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'services/reservation-service.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('services/restaurant-service.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'services/restaurant-service.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('services/session-service.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'services/session-service.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });
});
define('e-restaurant-fe/tests/helpers/destroy-app', ['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = destroyApp;
  function destroyApp(application) {
    Ember.run(application, 'destroy');
  }
});
define('e-restaurant-fe/tests/helpers/ember-cli-g-maps/register-async-helpers', ['exports', 'e-restaurant-fe/tests/helpers/ember-cli-g-maps/select-autocomplete-place-helper', 'e-restaurant-fe/tests/helpers/ember-cli-g-maps/wait-for-google-map-helper', 'e-restaurant-fe/tests/helpers/ember-cli-g-maps/wait-for-geocode-requests-helper', 'e-restaurant-fe/tests/helpers/ember-cli-g-maps/stub-geocode-requests-helper'], function (exports, _selectAutocompletePlaceHelper, _waitForGoogleMapHelper, _waitForGeocodeRequestsHelper, _stubGeocodeRequestsHelper) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function () {
    Ember.Test.registerAsyncHelper('selectPlace', function () {
      Ember.Logger.warn('Please replace disabled helper "selectPlace" with "selectAutocompletePlace" helper.\nUsage details here: http://http://matt-jensen.github.io/ember-cli-g-maps/#/place-autocomplete/index');
    });
    Ember.Test.registerAsyncHelper('selectAutocompletePlace', _selectAutocompletePlaceHelper.default);
    Ember.Test.registerAsyncHelper('waitForGoogleMap', _waitForGoogleMapHelper.default);
    Ember.Test.registerAsyncHelper('waitForGeocodeRequests', _waitForGeocodeRequestsHelper.default);
    Ember.Test.registerAsyncHelper('stubGeocodeRequests', _stubGeocodeRequestsHelper.default);
  };
});
define('e-restaurant-fe/tests/helpers/ember-cli-g-maps/select-autocomplete-place-helper', ['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (app) {
    var requestedResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var selector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.' + GAUTOCOMPLETE_CLASS;

    return new Ember.Test.promise(function (resolve, reject) {

      // User only provided selector argument
      if (typeof requestedResult === 'string') {
        selector = requestedResult;
        requestedResult = 0;
      }

      longPollExternalElement(GOOGLE_AUTOCOMPLETE_RESULTS).then(function (autocompletePlaces) {
        var textResults = autocompletePlaces.map(function (i, el) {
          return $(el).text();
        });

        var _app$testHelpers$find = app.testHelpers.find(selector),
            _app$testHelpers$find2 = _slicedToArray(_app$testHelpers$find, 1),
            input = _app$testHelpers$find2[0];

        assert('No g-autocomplete component found for selector: ' + selector, input && $(input).hasClass(GAUTOCOMPLETE_CLASS));

        var targetResult = 0;

        /*
         * Set target to requested result if it exists
         */
        if (requestedResult > 0 && requestedResult <= textResults.length - 1) {
          targetResult = parseInt(requestedResult, 10);
        }

        /*
         * Keydown to requested result (40 = down arrow)
         */
        for (var i = 0; i <= targetResult; i++) {
          google.maps.event.trigger(input, 'keydown', { keyCode: 40 });
        }

        // Select active result (13 = Enter)
        google.maps.event.trigger(input, 'keydown', { keyCode: 13 });
        Ember.run.later(function () {
          return resolve(textResults[targetResult]);
        }, 300);
      }, reject);
    });
  };

  exports.longPollExternalElement = longPollExternalElement;

  var _slicedToArray = function () {
    function sliceIterator(arr, i) {
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"]) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    return function (arr, i) {
      if (Array.isArray(arr)) {
        return arr;
      } else if (Symbol.iterator in Object(arr)) {
        return sliceIterator(arr, i);
      } else {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      }
    };
  }();

  var $ = Ember.$,
      assert = Ember.assert;

  var GAUTOCOMPLETE_CLASS = 'g-autocomplete';
  var GOOGLE_AUTOCOMPLETE_RESULTS = '.pac-container .pac-item';

  function longPollExternalElement(selector) {
    return new Ember.RSVP.Promise(function (resolve, reject) {
      var pollAgain = function () {
        var counter = 0;

        return function () {
          /*
           * NOTE searching for elements potentially outside of #ember-testing container
           */
          var results = $(selector);

          if (results.length) {
            return resolve(results);
          }

          if (counter > 5) {
            return reject();
          }

          counter++;
          Ember.run.later(pollAgain, 300);
        };
      }();

      pollAgain();
    });
  };
});
define("e-restaurant-fe/tests/helpers/ember-cli-g-maps/setup-test", ["exports"], function (exports) {
  "use strict";

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function () {};
});
define('e-restaurant-fe/tests/helpers/ember-cli-g-maps/stub-geocode-requests-helper', ['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (app) {
    var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var onlyPhantomJS = Boolean(config.onlyPhantomJS);

    // Abandon if only stubbing phantomJS
    if (onlyPhantomJS && IS_PHANTOMJS_ENV === false) {
      return;
    }

    assert('A results array is required', config.results && config.results instanceof Array && config.results.length);

    var stubs = void 0;
    if (config.results[0] instanceof Array) {
      // Clone 2 demensional array
      stubs = config.results.map(function (results) {
        return results.map(toPlaceResult);
      });
    } else {
      // Clone 1 demensional into 2 demensional array
      stubs = [config.results.map(toPlaceResult)];
    }

    assert('Geocode stubbed requests are still unresolved', ORIGINAL_GEOCODE === GMaps.prototype.geocode);

    var stubIndex = 0;

    /*
     * Stub GMaps geocode
     */
    GMaps.prototype.geocode = function geocodeStub(_ref) {
      var callback = _ref.callback;

      run(function () {
        callback(stubs[stubIndex], 'OK');
        stubIndex += 1;

        if (stubIndex >= stubs.length) {
          GMaps.prototype.geocode = ORIGINAL_GEOCODE;
        }
      });
    };
  };

  exports.toPlaceResult = toPlaceResult;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var RSVP = Ember.RSVP;
  var getOwner = Ember.getOwner;
  var assert = Ember.assert;
  var copy = Ember.copy;
  var run = Ember.run;
  var Logger = Ember.Logger;

  var ORIGINAL_GEOCODE = GMaps.prototype.geocode;
  var IS_PHANTOMJS_ENV = (typeof window === 'undefined' ? 'undefined' : _typeof(window)) === 'object' && window.hasOwnProperty('_phantom');

  function toPlaceResult(result) {
    var clone = copy(result, true);
    clone.geometry = clone.geometry || {};
    clone.geometry.location = clone.geometry.location || {};

    if (clone.hasOwnProperty('lat') && typeof clone.geometry.location.lat !== 'function') {
      clone.geometry.location.lat = function () {
        return clone.lat;
      };
    }

    if (clone.hasOwnProperty('lng') && typeof clone.geometry.location.lng !== 'function') {
      clone.geometry.location.lng = function () {
        return clone.lng;
      };
    }

    if (clone.hasOwnProperty('address') && !clone.formatted_address) {
      clone.formatted_address = clone.address;
    }

    return clone;
  }
});
define('e-restaurant-fe/tests/helpers/ember-cli-g-maps/wait-for-geocode-requests-helper', ['exports'], function (exports) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (app) {
    var container = getOwner(app) || app.__container__;
    assert('failed to recover application container', container);

    var gMap = container.lookup && container.lookup('service:gMap');
    assert('gMap service lookup failed', gMap);

    return new Ember.Test.promise(function (resolve, reject) {
      Ember.Test.adapter.asyncStart();

      var queue = gMap._geocodeQueue || [];

      if (!queue.length) {
        Logger.warn('Geocode request queue was not found, or is currently empty');
      }

      return RSVP.Promise.all(queue).then(function () {
        Ember.run.scheduleOnce('afterRender', null, resolve);
        Ember.Test.adapter.asyncEnd();
      }).catch(function () {
        reject();
        Ember.Test.adapter.asyncEnd();
      });
    });
  };

  var RSVP = Ember.RSVP;
  var getOwner = Ember.getOwner;
  var assert = Ember.assert;
  var Logger = Ember.Logger;
});
define('e-restaurant-fe/tests/helpers/ember-cli-g-maps/wait-for-google-map-helper', ['exports', 'ember-cli-g-maps/utils/load-google-maps'], function (exports, _loadGoogleMaps) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (app) {
    var selector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EMBER_CLI_GMAPS_SELECTOR;

    return new Ember.Test.promise(function (resolve, reject) {
      Ember.Test.adapter.asyncStart();

      (0, _loadGoogleMaps.default)().then(function () {
        Ember.run.scheduleOnce('afterRender', function () {
          var $map = $(selector);
          assert('No g-maps component found at selector: ' + selector, !$map.length || !$map.eq(0).hasClass(EMBER_CLI_GMAPS_SELECTOR));

          google.maps.event.addListenerOnce($map.get(0).__GOOGLE_MAP__, 'tilesloaded', function () {
            Ember.run(resolve);
            Ember.Test.adapter.asyncEnd();
          });
        });
      }).catch(function () {
        reject();
        Ember.Test.adapter.asyncEnd();
      });
    });
  };

  var $ = Ember.$,
      assert = Ember.assert;

  var EMBER_CLI_GMAPS_SELECTOR = '.ember-cli-g-map';
});
define('e-restaurant-fe/tests/helpers/module-for-acceptance', ['exports', 'qunit', 'e-restaurant-fe/tests/helpers/start-app', 'e-restaurant-fe/tests/helpers/destroy-app'], function (exports, _qunit, _startApp, _destroyApp) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function (name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    (0, _qunit.module)(name, {
      beforeEach: function beforeEach() {
        this.application = (0, _startApp.default)();

        if (options.beforeEach) {
          return options.beforeEach.apply(this, arguments);
        }
      },
      afterEach: function afterEach() {
        var _this = this;

        var afterEach = options.afterEach && options.afterEach.apply(this, arguments);
        return Promise.resolve(afterEach).then(function () {
          return (0, _destroyApp.default)(_this.application);
        });
      }
    });
  };

  var Promise = Ember.RSVP.Promise;
});
define('e-restaurant-fe/tests/helpers/resolver', ['exports', 'e-restaurant-fe/resolver', 'e-restaurant-fe/config/environment'], function (exports, _resolver, _environment) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });


  var resolver = _resolver.default.create();

  resolver.namespace = {
    modulePrefix: _environment.default.modulePrefix,
    podModulePrefix: _environment.default.podModulePrefix
  };

  exports.default = resolver;
});
define('e-restaurant-fe/tests/helpers/start-app', ['exports', 'e-restaurant-fe/app', 'e-restaurant-fe/config/environment'], function (exports, _app, _environment) {
  'use strict';

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = startApp;
  function startApp(attrs) {
    var attributes = Ember.merge({}, _environment.default.APP);
    attributes = Ember.merge(attributes, attrs); // use defaults, but you can override;

    return Ember.run(function () {
      var application = _app.default.create(attributes);
      application.setupForTesting();
      application.injectTestHelpers();
      return application;
    });
  }
});
define('e-restaurant-fe/tests/integration/components/restaurant-basic-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleForComponent)('restaurant-basic', 'Integration | Component | restaurant basic', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {

    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template({
      "id": "1vZDZQxC",
      "block": "{\"statements\":[[1,[26,[\"restaurant-basic\"]],false]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    this.render(Ember.HTMLBars.template({
      "id": "9o2VuiHi",
      "block": "{\"statements\":[[0,\"\\n\"],[6,[\"restaurant-basic\"],null,null,{\"statements\":[[0,\"      template block text\\n\"]],\"locals\":[]},null],[0,\"  \"]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('e-restaurant-fe/tests/integration/components/restaurant-menu-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleForComponent)('restaurant-menu', 'Integration | Component | restaurant menu', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {

    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template({
      "id": "9e9HkU+7",
      "block": "{\"statements\":[[1,[26,[\"restaurant-menu\"]],false]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    this.render(Ember.HTMLBars.template({
      "id": "i770v9cZ",
      "block": "{\"statements\":[[0,\"\\n\"],[6,[\"restaurant-menu\"],null,null,{\"statements\":[[0,\"      template block text\\n\"]],\"locals\":[]},null],[0,\"  \"]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('e-restaurant-fe/tests/integration/components/restaurant-tables-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleForComponent)('restaurant-tables', 'Integration | Component | restaurant tables', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {

    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template({
      "id": "VTVr9nBw",
      "block": "{\"statements\":[[1,[26,[\"restaurant-tables\"]],false]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    this.render(Ember.HTMLBars.template({
      "id": "XI/gTbKn",
      "block": "{\"statements\":[[0,\"\\n\"],[6,[\"restaurant-tables\"],null,null,{\"statements\":[[0,\"      template block text\\n\"]],\"locals\":[]},null],[0,\"  \"]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('e-restaurant-fe/tests/integration/components/table-search-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleForComponent)('table-search', 'Integration | Component | table search', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {

    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template({
      "id": "hetESTrd",
      "block": "{\"statements\":[[1,[26,[\"table-search\"]],false]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    this.render(Ember.HTMLBars.template({
      "id": "KzkhEpqM",
      "block": "{\"statements\":[[0,\"\\n\"],[6,[\"table-search\"],null,null,{\"statements\":[[0,\"      template block text\\n\"]],\"locals\":[]},null],[0,\"  \"]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('e-restaurant-fe/tests/integration/components/update-restaurant-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleForComponent)('update-restaurant', 'Integration | Component | update restaurant', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {

    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template({
      "id": "txwX1Jcs",
      "block": "{\"statements\":[[1,[26,[\"update-restaurant\"]],false]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    this.render(Ember.HTMLBars.template({
      "id": "aIGE+2HC",
      "block": "{\"statements\":[[0,\"\\n\"],[6,[\"update-restaurant\"],null,null,{\"statements\":[[0,\"      template block text\\n\"]],\"locals\":[]},null],[0,\"  \"]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('e-restaurant-fe/tests/integration/components/update-user-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleForComponent)('update-user', 'Integration | Component | update user', {
    integration: true
  });

  (0, _emberQunit.test)('it renders', function (assert) {

    // Set any properties with this.set('myProperty', 'value');
    // Handle any actions with this.on('myAction', function(val) { ... });

    this.render(Ember.HTMLBars.template({
      "id": "Fo2ap1ad",
      "block": "{\"statements\":[[1,[26,[\"update-user\"]],false]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), '');

    // Template block usage:
    this.render(Ember.HTMLBars.template({
      "id": "9N9hGvBH",
      "block": "{\"statements\":[[0,\"\\n\"],[6,[\"update-user\"],null,null,{\"statements\":[[0,\"      template block text\\n\"]],\"locals\":[]},null],[0,\"  \"]],\"locals\":[],\"named\":[],\"yields\":[],\"hasPartials\":false}",
      "meta": {}
    }));

    assert.equal(this.$().text().trim(), 'template block text');
  });
});
define('e-restaurant-fe/tests/test-helper', ['e-restaurant-fe/tests/helpers/resolver', 'ember-qunit', 'ember-cli-qunit'], function (_resolver, _emberQunit, _emberCliQunit) {
  'use strict';

  (0, _emberQunit.setResolver)(_resolver.default);
  (0, _emberCliQunit.start)();
});
define('e-restaurant-fe/tests/tests.lint-test', [], function () {
  'use strict';

  QUnit.module('ESLint | tests');

  QUnit.test('helpers/destroy-app.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'helpers/destroy-app.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('helpers/module-for-acceptance.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'helpers/module-for-acceptance.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('helpers/resolver.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'helpers/resolver.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('helpers/start-app.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'helpers/start-app.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('integration/components/restaurant-basic-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'integration/components/restaurant-basic-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('integration/components/restaurant-menu-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'integration/components/restaurant-menu-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('integration/components/restaurant-tables-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'integration/components/restaurant-tables-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('integration/components/table-search-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'integration/components/table-search-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('integration/components/update-restaurant-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'integration/components/update-restaurant-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('integration/components/update-user-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'integration/components/update-user-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('test-helper.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'test-helper.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('unit/controllers/add-restaurant-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'unit/controllers/add-restaurant-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('unit/controllers/reservation-bar-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'unit/controllers/reservation-bar-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });

  QUnit.test('unit/services/admin-service-test.js', function (assert) {
    assert.expect(1);
    assert.ok(false, 'unit/services/admin-service-test.js should pass ESLint\n\n1:1 - Parsing error: The keyword \'import\' is reserved (null)');
  });
});
define('e-restaurant-fe/tests/unit/controllers/add-restaurant-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleFor)('controller:add-restaurant', 'Unit | Controller | add restaurant', {
    // Specify the other units that are required for this test.
    // needs: ['controller:foo']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it exists', function (assert) {
    var controller = this.subject();
    assert.ok(controller);
  });
});
define('e-restaurant-fe/tests/unit/controllers/reservation-bar-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleFor)('controller:reservation-bar', 'Unit | Controller | reservation bar', {
    // Specify the other units that are required for this test.
    // needs: ['controller:foo']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it exists', function (assert) {
    var controller = this.subject();
    assert.ok(controller);
  });
});
define('e-restaurant-fe/tests/unit/services/admin-service-test', ['ember-qunit'], function (_emberQunit) {
  'use strict';

  (0, _emberQunit.moduleFor)('service:admin-service', 'Unit | Service | admin service', {
    // Specify the other units that are required for this test.
    // needs: ['service:foo']
  });

  // Replace this with your real tests.
  (0, _emberQunit.test)('it exists', function (assert) {
    var service = this.subject();
    assert.ok(service);
  });
});
require('e-restaurant-fe/tests/test-helper');
EmberENV.TESTS_FILE_LOADED = true;
//# sourceMappingURL=tests.map
